import unittest

# Adapter l'import selon l'organisation du projet
try:
    from arslm.adaptive_sequence import AdaptiveSequence
except ImportError:
    from adaptive_sequence import AdaptiveSequence

class TestAdaptiveSequenceExtremes(unittest.TestCase):

    def test_long_complex_pattern(self):
        """Motif complexe mélangeant toutes les opérations"""
        seq = AdaptiveSequence(5, -3, pattern=['+', '-', '*', '-', '+', '*', '+'])
        result = seq.generate(12)
        self.assertIsInstance(result, list)
        self.assertEqual(len(result), 12)

    def test_negative_initial_values(self):
        seq = AdaptiveSequence(-100, -200, pattern=['+', '-'])
        result = seq.generate(5)
        self.assertTrue(all(isinstance(v, (int, float)) for v in result))

    def test_large_values(self):
        seq = AdaptiveSequence(10**9, 10**8, pattern=['+', '*'])
        result = seq.generate(5)
        self.assertEqual(len(result), 5)
        self.assertTrue(all(isinstance(v, (int, float)) for v in result))

    def test_zero_division_in_pattern(self):
        seq = AdaptiveSequence(10, 0, pattern=['/'])
        result = seq.generate(4)
        self.assertEqual(len(result), 4)
        # float('inf') attendu si division par zéro
        self.assertIn(float('inf'), result)

    def test_empty_pattern(self):
        with self.assertRaises(Exception):
            seq = AdaptiveSequence(1, 2, pattern=[])
            seq.generate(5)

    def test_one_element_pattern(self):
        seq = AdaptiveSequence(3, 2, pattern=['*'])
        result = seq.generate(6)
        self.assertEqual(result, [3, 2, 6, 12, 72, 864])

    def test_pattern_longer_than_length(self):
        seq = AdaptiveSequence(1, 2, pattern=['+', '-', '*', '/'])
        result = seq.generate(3)
        self.assertEqual(len(result), 3)

if __name__ == "__main__":
    unittest.main()